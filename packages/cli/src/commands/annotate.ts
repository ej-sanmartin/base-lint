import path from 'path';
import { readJSON } from '../fs-helpers.js';
import type { Report, Finding } from '../core/analyze.js';
import { logger } from '../logger.js';

interface AnnotateOptions {
  input: string;
  batchSize?: string;
}

export async function runAnnotateCommand(options: AnnotateOptions): Promise<void> {
  const cwd = process.cwd();
  const inputPath = path.resolve(cwd, options.input);
  const report = await readJSON<Report>(inputPath);

  const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;
  const repo = process.env.GITHUB_REPOSITORY;
  const eventName = process.env.GITHUB_EVENT_NAME ?? '';
  const sha = process.env.GITHUB_SHA;

  if (!token || !repo || !sha) {
    logger.info('GitHub context not detected. Skipping annotations.');
    return;
  }

  if (eventName.startsWith('pull_request')) {
    const context = await readPullRequestContext();
    if (context?.isFork) {
      logger.info('Pull request originates from a fork. Skipping annotations.');
      return;
    }
  }

  const annotations = buildAnnotations(report.findings, report.meta.treatNewlyAs);
  const batchSize = Math.max(1, Number(options.batchSize ?? '50'));
  const summary = `Limited: ${report.summary.limited} · Newly: ${report.summary.newly} · Widely: ${report.summary.widely}`;
  const conclusion = determineConclusion(report);

  const [owner, repoName] = repo.split('/');
  const name = 'Base Lint';
  const now = new Date().toISOString();
  const baseOutput = {
    title: name,
    summary,
    text: 'Generated by base-lint.',
  };

  const firstChunk = annotations.slice(0, batchSize);
  const response = await githubRequest(`https://api.github.com/repos/${owner}/${repoName}/check-runs`, token, {
    method: 'POST',
    body: JSON.stringify({
      name,
      head_sha: sha,
      status: 'completed',
      conclusion,
      completed_at: now,
      output: {
        ...baseOutput,
        annotations: firstChunk,
      },
    }),
  });

  if (!response.ok) {
    if (response.status === 403 || response.status === 404) {
      logger.warn(`Insufficient permissions to create check run (status ${response.status}).`);
      return;
    }
    throw new Error(`Failed to create check run: ${response.status}`);
  }

  const data = (await response.json()) as { id?: number };
  const checkId = data.id;
  if (!checkId) {
    logger.warn('Check run created without id. Skipping additional annotations.');
    return;
  }

  const remaining = annotations.slice(batchSize);
  if (remaining.length === 0) {
    return;
  }

  const chunks: Annotation[][] = [];
  for (let i = 0; i < remaining.length; i += batchSize) {
    chunks.push(remaining.slice(i, i + batchSize));
  }

  for (const chunk of chunks) {
    const patchResponse = await githubRequest(
      `https://api.github.com/repos/${owner}/${repoName}/check-runs/${checkId}`,
      token,
      {
        method: 'PATCH',
        body: JSON.stringify({
          status: 'completed',
          conclusion,
          completed_at: new Date().toISOString(),
          output: {
            ...baseOutput,
            annotations: chunk,
          },
        }),
      }
    );
    if (!patchResponse.ok) {
      logger.warn(`Failed to append annotations (status ${patchResponse.status}).`);
      break;
    }
  }
}

interface Annotation {
  path: string;
  start_line: number;
  end_line: number;
  start_column?: number;
  end_column?: number;
  annotation_level: 'notice' | 'warning' | 'failure';
  title: string;
  message: string;
}

function buildAnnotations(findings: Finding[], treatNewlyAs: Report['meta']['treatNewlyAs']): Annotation[] {
  const annotations: Annotation[] = [];
  for (const finding of findings) {
    if (finding.baseline === 'widely') {
      continue;
    }
    const level = mapLevel(finding.baseline, treatNewlyAs);
    const line = finding.line ?? 1;
    const column = finding.column ?? undefined;
    annotations.push({
      path: finding.file,
      start_line: line,
      end_line: line,
      start_column: column,
      end_column: column,
      annotation_level: level,
      title: finding.featureName,
      message: `${finding.featureName} is ${finding.baseline}. ${finding.guidance}`,
    });
  }
  return annotations;
}

function mapLevel(level: Finding['baseline'], treatNewlyAs: Report['meta']['treatNewlyAs']): Annotation['annotation_level'] {
  if (level === 'limited') {
    return 'failure';
  }
  if (treatNewlyAs === 'error') {
    return 'failure';
  }
  if (treatNewlyAs === 'ignore') {
    return 'notice';
  }
  return 'warning';
}

function determineConclusion(report: Report): 'success' | 'failure' | 'neutral' {
  if (report.summary.limited > 0) {
    return 'failure';
  }
  if (report.meta.treatNewlyAs === 'error' && report.summary.newly > 0) {
    return 'failure';
  }
  if (report.summary.newly > 0) {
    return 'neutral';
  }
  return 'success';
}

async function readPullRequestContext(): Promise<{ isFork: boolean } | null> {
  const eventPath = process.env.GITHUB_EVENT_PATH;
  if (!eventPath) {
    return null;
  }
  try {
    const payload = await readJSON<any>(eventPath);
    const baseRepo = payload?.pull_request?.base?.repo?.full_name;
    const headRepo = payload?.pull_request?.head?.repo?.full_name;
    const isFork = Boolean(headRepo && baseRepo && headRepo !== baseRepo);
    return { isFork };
  } catch (error) {
    logger.warn(`Failed to read event payload: ${(error as Error).message}`);
    return null;
  }
}

async function githubRequest(url: string, token: string, init: RequestInit = {}): Promise<Response> {
  const headers = new Headers(init.headers ?? {});
  headers.set('Authorization', `Bearer ${token}`);
  headers.set('Accept', 'application/vnd.github+json');
  headers.set('User-Agent', 'base-lint-cli');
  return fetch(url, {
    ...init,
    headers,
  });
}
